<?php

declare(strict_types=1);

namespace Stumason\Coolify\Nixpacks;

use Illuminate\Support\Facades\File;
use Stumason\Coolify\Nixpacks\Detectors\HorizonDetector;
use Stumason\Coolify\Nixpacks\Detectors\PackageDetector;
use Stumason\Coolify\Nixpacks\Detectors\ReverbDetector;
use Stumason\Coolify\Nixpacks\Detectors\SchedulerDetector;

class NixpacksGenerator
{
    /** @var array<PackageDetector> */
    protected array $detectors = [];

    /** @var array<PackageDetector> */
    protected array $detected = [];

    protected bool $hasDetected = false;

    protected ?bool $hasNode = null;

    public function __construct()
    {
        $this->detectors = [
            new HorizonDetector,
            new ReverbDetector,
            new SchedulerDetector,
        ];
    }

    /**
     * Run detection and return list of detected packages.
     *
     * @return array<PackageDetector>
     */
    public function detect(): array
    {
        if ($this->hasDetected) {
            return $this->detected;
        }

        $this->detected = [];

        foreach ($this->detectors as $detector) {
            if ($detector->isInstalled()) {
                $this->detected[] = $detector;
            }
        }

        $this->hasDetected = true;

        return $this->detected;
    }

    /**
     * @return array<PackageDetector>
     */
    public function getDetected(): array
    {
        return $this->detected;
    }

    /**
     * Generate the complete nixpacks.toml content.
     */
    public function generate(): string
    {
        $sections = [];

        $sections[] = $this->generateHeader();
        $sections[] = $this->generateSetupPhase();
        $sections[] = $this->generateInstallPhase();
        $sections[] = $this->generateBuildPhase();
        $sections[] = $this->generatePostBuildPhase();
        $sections[] = $this->generateStartSection();
        $sections[] = $this->generateStaticAssets();

        return implode("\n", array_filter($sections));
    }

    protected function generateHeader(): string
    {
        return <<<'TOML'
# Generated by laravel-coolify
# https://github.com/stumason/laravel-coolify

TOML;
    }

    protected function generateSetupPhase(): string
    {
        $phpVersion = config('coolify.nixpacks.php_version', 'php84');
        $nodeVersion = config('coolify.nixpacks.node_version', 'nodejs_22');

        // Collect PHP extensions from detectors
        $extensions = ['redis']; // Redis is always needed for Laravel caching/sessions
        foreach ($this->detected as $detector) {
            $extensions = array_merge($extensions, $detector->getPhpExtensions());
        }
        $extensions = array_unique($extensions);
        $extensionList = implode(' ', $extensions);

        $packages = [
            "\"({$phpVersion}.withExtensions ({ enabled, all }: enabled ++ (with all; [ {$extensionList} ])))\"",
            "\"{$phpVersion}Packages.composer\"",
            '"nginx"',
            '"python311Packages.supervisor"',
            '"libcap"', // For setcap to allow nginx to bind to port 80
        ];

        if ($this->hasNodeDependencies()) {
            array_unshift($packages, "\"{$nodeVersion}\"");
        }

        $nixPkgs = implode(', ', $packages);

        return <<<TOML
[phases.setup]
nixPkgs = [{$nixPkgs}]

TOML;
    }

    protected function generateInstallPhase(): string
    {
        $lines = ['[phases.install]'];

        // Cache composer's global cache for faster downloads
        $lines[] = 'cacheDirectories = ["/root/.composer/cache"]';

        // Install phase runs npm ci to install node_modules (happens BEFORE COPY)
        // npm run build is deferred to postbuild because plugins like @laravel/vite-plugin-wayfinder
        // need the vendor directory (which is installed via composer in postbuild)
        if ($this->hasNodeDependencies()) {
            $lines[] = 'cmds = [';
            $lines[] = '    "npm ci",';
            $lines[] = ']';
        } else {
            $lines[] = 'cmds = []';
        }

        $lines[] = '';

        return implode("\n", $lines);
    }

    protected function generateBuildPhase(): string
    {
        $lines = ['[phases.build]'];
        $lines[] = 'dependsOn = ["install"]';
        $lines[] = 'cmds = [';
        $lines[] = '    # Create required directories';
        $lines[] = '    "mkdir -p /var/log /app/storage/framework/{views,cache,sessions} /app/bootstrap/cache /etc/supervisor/conf.d",';
        $lines[] = '';
        $lines[] = '    # Set permissions';
        $lines[] = '    "chown -R www-data:www-data /var/log /app/storage /app/bootstrap/cache 2>/dev/null || true",';
        $lines[] = '';
        $lines[] = '    # Allow nginx to bind to privileged ports (80) without running as root';
        $lines[] = '    "setcap \'cap_net_bind_service=+ep\' $(which nginx) 2>/dev/null || true",';
        $lines[] = '';
        $lines[] = '    # Copy supervisor configs';
        $lines[] = '    "cp /assets/worker-*.conf /etc/supervisor/conf.d/",';
        $lines[] = '    "cp /assets/supervisord.conf /etc/supervisord.conf",';
        $lines[] = '    "chmod +x /assets/start.sh",';
        $lines[] = ']';
        $lines[] = '';

        return implode("\n", $lines);
    }

    protected function generatePostBuildPhase(): string
    {
        $lines = ['[phases.postbuild]'];
        $lines[] = 'dependsOn = ["build"]';

        // postbuild runs AFTER `COPY . /app` so vendor will persist in final image
        // Order matters: composer first (for autoloader), then npm build (needs vendor for wayfinder), then optimize
        $lines[] = 'cmds = [';
        $lines[] = '    "composer install --no-dev --optimize-autoloader",';
        if ($this->hasNodeDependencies()) {
            $lines[] = '    "npm run build",';
        }
        $lines[] = '    "php artisan optimize",';
        $lines[] = ']';
        $lines[] = '';

        return implode("\n", $lines);
    }

    protected function generateStartSection(): string
    {
        return <<<'TOML'
[start]
cmd = "/assets/start.sh"

TOML;
    }

    protected function generateStaticAssets(): string
    {
        $lines = ['[staticAssets]'];

        // Start script
        $lines[] = $this->generateStartScript();

        // Supervisord config
        $lines[] = $this->generateSupervisordConfig();

        // Core workers (always present)
        $lines[] = $this->generateNginxWorkerConfig();
        $lines[] = $this->generatePhpFpmWorkerConfig();

        // Detected package workers
        foreach ($this->detected as $detector) {
            $config = $detector->getSupervisorConfig();
            if ($config !== null) {
                $workerName = $this->getWorkerNameFromConfig($config);
                $lines[] = "\"{$workerName}.conf\" = '''";
                $lines[] = $config;
                $lines[] = "'''";
                $lines[] = '';
            }
        }

        // PHP-FPM config
        $lines[] = $this->generatePhpFpmConfig();

        // Nginx template
        $lines[] = $this->generateNginxTemplate();

        return implode("\n", $lines);
    }

    protected function generateStartScript(): string
    {
        return <<<'TOML'
"start.sh" = '''
#!/bin/bash
set -e

# Run database migrations
php artisan migrate --force --no-interaction

# Create storage symlink
php artisan storage:link --force 2>/dev/null || true

# Transform the nginx configuration
node /assets/scripts/prestart.mjs /assets/nginx.template.conf /etc/nginx.conf

# Start supervisor
exec supervisord -c /etc/supervisord.conf -n
'''

TOML;
    }

    protected function generateSupervisordConfig(): string
    {
        return <<<'TOML'
"supervisord.conf" = '''
[unix_http_server]
file=/assets/supervisor.sock

[supervisord]
logfile=/var/log/supervisord.log
logfile_maxbytes=50MB
logfile_backups=10
loglevel=info
pidfile=/assets/supervisord.pid
nodaemon=false
silent=false
minfds=1024
minprocs=200

[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface

[supervisorctl]
serverurl=unix:///assets/supervisor.sock

[include]
files = /etc/supervisor/conf.d/*.conf
'''

TOML;
    }

    protected function generateNginxWorkerConfig(): string
    {
        return <<<'TOML'
"worker-nginx.conf" = '''
[program:worker-nginx]
process_name=%(program_name)s_%(process_num)02d
command=nginx -c /etc/nginx.conf
autostart=true
autorestart=true
stdout_logfile=/var/log/worker-nginx.log
stderr_logfile=/var/log/worker-nginx.log
'''

TOML;
    }

    protected function generatePhpFpmWorkerConfig(): string
    {
        return <<<'TOML'
"worker-phpfpm.conf" = '''
[program:worker-phpfpm]
process_name=%(program_name)s_%(process_num)02d
command=php-fpm -y /assets/php-fpm.conf -F
autostart=true
autorestart=true
stdout_logfile=/var/log/worker-phpfpm.log
stderr_logfile=/var/log/worker-phpfpm.log
'''

TOML;
    }

    protected function generatePhpFpmConfig(): string
    {
        $maxChildren = config('coolify.nixpacks.phpfpm.max_children', 50);
        $startServers = config('coolify.nixpacks.phpfpm.start_servers', 18);
        $minSpare = config('coolify.nixpacks.phpfpm.min_spare_servers', 4);
        $maxSpare = config('coolify.nixpacks.phpfpm.max_spare_servers', 32);

        return <<<TOML
"php-fpm.conf" = '''
[www]
listen = 127.0.0.1:9000
user = www-data
group = www-data
listen.owner = www-data
listen.group = www-data
pm = dynamic
pm.max_children = {$maxChildren}
pm.min_spare_servers = {$minSpare}
pm.max_spare_servers = {$maxSpare}
pm.start_servers = {$startServers}
clear_env = no
'''

TOML;
    }

    protected function generateNginxTemplate(): string
    {
        $clientMaxBodySize = config('coolify.nixpacks.nginx.client_max_body_size', '35M');
        $uploadMaxFilesize = config('coolify.nixpacks.nginx.upload_max_filesize', '30M');
        $postMaxSize = config('coolify.nixpacks.nginx.post_max_size', '35M');

        // Collect nginx location blocks from detectors
        $extraLocations = [];
        foreach ($this->detected as $detector) {
            $extraLocations = array_merge($extraLocations, $detector->getNginxLocationBlocks());
        }
        $extraLocationStr = implode("\n\n", $extraLocations);

        // Use nowdoc for the template since it contains special characters
        $template = <<<NGINX
"nginx.template.conf" = '''
user www-data www-data;
worker_processes auto;
daemon off;

worker_rlimit_nofile 8192;

events {
  worker_connections 4096;
}

http {
    include    \$!{nginx}/conf/mime.types;
    index    index.html index.htm index.php;

    default_type application/octet-stream;
    log_format   main '\$remote_addr - \$remote_user [\$time_local]  \$status '
        '"\$request" \$body_bytes_sent "\$http_referer" '
        '"\$http_user_agent" "\$http_x_forwarded_for"';
    access_log /var/log/nginx-access.log;
    error_log /var/log/nginx-error.log;
    sendfile     on;
    tcp_nopush   on;
    server_names_hash_bucket_size 128;

    server {
        listen \${PORT};
        listen [::]:\${PORT};
        server_name localhost;

        \$if(NIXPACKS_PHP_ROOT_DIR) (
            root \${NIXPACKS_PHP_ROOT_DIR};
        ) else (
            root /app/public;
        )

        add_header X-Content-Type-Options "nosniff";

        client_max_body_size {$clientMaxBodySize};

        index index.php;

        charset utf-8;

        location / {
            try_files \$uri \$uri/ /index.php?\$query_string;
        }

        location = /favicon.ico { access_log off; log_not_found off; }
        location = /robots.txt  { access_log off; log_not_found off; }

{$extraLocationStr}

        error_page 404 /index.php;

        location ~ \.php\$ {
            fastcgi_pass 127.0.0.1:9000;
            fastcgi_param SCRIPT_FILENAME \$realpath_root\$fastcgi_script_name;
            include \$!{nginx}/conf/fastcgi_params;
            include \$!{nginx}/conf/fastcgi.conf;

            fastcgi_param PHP_VALUE "upload_max_filesize={$uploadMaxFilesize} \\n post_max_size={$postMaxSize}";
        }

        location ~ /\.(?!well-known).* {
            deny all;
        }
    }
}
'''

NGINX;

        return $template;
    }

    protected function getWorkerNameFromConfig(string $config): string
    {
        if (preg_match('/\[program:(worker-[a-z]+)\]/', $config, $matches)) {
            return $matches[1];
        }

        return 'worker-unknown';
    }

    /**
     * Write the nixpacks.toml file.
     */
    public function write(?string $path = null): string
    {
        $path = $path ?? base_path('nixpacks.toml');

        $realPath = realpath(dirname($path));
        $basePath = base_path();

        if ($realPath === false || ! str_starts_with($realPath, $basePath)) {
            throw new \InvalidArgumentException(
                'Path must be within the project directory'
            );
        }

        $content = $this->generate();

        File::put($path, $content);

        return $path;
    }

    public function exists(): bool
    {
        return File::exists(base_path('nixpacks.toml'));
    }

    protected function hasNodeDependencies(): bool
    {
        if ($this->hasNode === null) {
            $this->hasNode = File::exists(base_path('package.json'));
        }

        return $this->hasNode;
    }

    /**
     * Get a summary of what will be generated.
     *
     * @return array{packages: array<string>, workers: array<string>, php_extensions: array<string>}
     */
    public function getSummary(): array
    {
        $workers = ['nginx', 'php-fpm'];
        $extensions = ['redis'];

        foreach ($this->detected as $detector) {
            if ($detector->getSupervisorConfig() !== null) {
                $config = $detector->getSupervisorConfig();
                $workerName = $this->getWorkerNameFromConfig($config);
                $workers[] = str_replace('worker-', '', $workerName);
            }
            $extensions = array_merge($extensions, $detector->getPhpExtensions());
        }

        return [
            'packages' => array_map(fn ($d) => $d->name(), $this->detected),
            'workers' => $workers,
            'php_extensions' => array_unique($extensions),
        ];
    }
}
