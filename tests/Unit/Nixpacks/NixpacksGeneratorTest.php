<?php

declare(strict_types=1);

use Illuminate\Support\Facades\File;
use Stumason\Coolify\Nixpacks\Detectors\HorizonDetector;
use Stumason\Coolify\Nixpacks\Detectors\ReverbDetector;
use Stumason\Coolify\Nixpacks\Detectors\SchedulerDetector;
use Stumason\Coolify\Nixpacks\NixpacksGenerator;

beforeEach(function () {
    // Clean up any existing nixpacks.toml
    $path = base_path('nixpacks.toml');
    if (File::exists($path)) {
        File::delete($path);
    }
});

afterEach(function () {
    // Clean up after tests
    $path = base_path('nixpacks.toml');
    if (File::exists($path)) {
        File::delete($path);
    }
});

describe('NixpacksGenerator', function () {
    it('detects installed packages', function () {
        $generator = new NixpacksGenerator;
        $detected = $generator->detect();

        // In test environment, none of these packages should be installed
        expect($detected)->toBeArray();
    });

    it('generates valid toml content', function () {
        $generator = new NixpacksGenerator;
        $generator->detect();

        $content = $generator->generate();

        expect($content)->toContain('# Generated by laravel-coolify');
        expect($content)->toContain('[phases.build]');
        expect($content)->toContain('[start]');
        expect($content)->toContain('composer install --no-dev --optimize-autoloader');
        expect($content)->toContain('php artisan config:cache');
        expect($content)->toContain('php artisan route:cache');
        expect($content)->toContain('php artisan view:cache');
    });

    it('writes nixpacks.toml file', function () {
        $generator = new NixpacksGenerator;
        $generator->detect();

        $path = $generator->write();

        expect(File::exists($path))->toBeTrue();
        expect(File::get($path))->toContain('[phases.build]');
    });

    it('detects when nixpacks.toml exists', function () {
        $generator = new NixpacksGenerator;

        expect($generator->exists())->toBeFalse();

        File::put(base_path('nixpacks.toml'), '# test');

        expect($generator->exists())->toBeTrue();
    });

    it('includes node build commands when package.json exists', function () {
        // Create a temporary package.json
        File::put(base_path('package.json'), '{}');

        $generator = new NixpacksGenerator;
        $generator->detect();

        $content = $generator->generate();

        expect($content)->toContain('npm ci');
        expect($content)->toContain('npm run build');

        // Clean up
        File::delete(base_path('package.json'));
    });

    it('returns summary of generated config', function () {
        $generator = new NixpacksGenerator;
        $generator->detect();

        $summary = $generator->getSummary();

        expect($summary)->toHaveKeys(['packages', 'processes', 'nix_packages']);
        expect($summary['processes'])->toHaveKey('web');
        expect($summary['processes']['web'])->toBe('php-fpm');
    });

    it('uses php-fpm as default web command', function () {
        $generator = new NixpacksGenerator;
        $generator->detect();

        $content = $generator->generate();

        expect($content)->toContain('cmd = "php-fpm"');
    });

    it('uses configurable web command', function () {
        config(['coolify.nixpacks.web_command' => 'php artisan octane:start --host=0.0.0.0 --port=8080']);

        $generator = new NixpacksGenerator;
        $generator->detect();

        $content = $generator->generate();

        expect($content)->toContain('cmd = "php artisan octane:start --host=0.0.0.0 --port=8080"');

        // Reset config
        config(['coolify.nixpacks.web_command' => 'php-fpm']);
    });
});

describe('HorizonDetector', function () {
    it('returns correct name', function () {
        $detector = new HorizonDetector;

        expect($detector->name())->toBe('Laravel Horizon');
    });

    it('returns horizon process', function () {
        $detector = new HorizonDetector;

        expect($detector->getProcesses())->toBe([
            'horizon' => 'php artisan horizon',
        ]);
    });

    it('returns empty nix packages (extensions handled via composer.json)', function () {
        $detector = new HorizonDetector;

        // Nixpacks auto-detects PHP extensions from composer.json's ext-* requirements
        expect($detector->getNixPackages())->toBe([]);
    });
});

describe('ReverbDetector', function () {
    it('returns correct name', function () {
        $detector = new ReverbDetector;

        expect($detector->name())->toBe('Laravel Reverb');
    });

    it('returns reverb process with correct host and port', function () {
        $detector = new ReverbDetector;

        expect($detector->getProcesses())->toBe([
            'reverb' => 'php artisan reverb:start --host=0.0.0.0 --port=8080',
        ]);
    });
});

describe('SchedulerDetector', function () {
    it('returns correct name', function () {
        $detector = new SchedulerDetector;

        expect($detector->name())->toBe('Task Scheduler');
    });

    it('returns scheduler process', function () {
        $detector = new SchedulerDetector;

        expect($detector->getProcesses())->toBe([
            'scheduler' => 'php artisan schedule:work',
        ]);
    });

    it('returns empty nix packages', function () {
        $detector = new SchedulerDetector;

        expect($detector->getNixPackages())->toBe([]);
    });

    it('returns empty build commands', function () {
        $detector = new SchedulerDetector;

        expect($detector->getBuildCommands())->toBe([]);
    });

    it('returns empty env vars', function () {
        $detector = new SchedulerDetector;

        expect($detector->getEnvVars())->toBe([]);
    });
});

describe('SchedulerDetector comment stripping', function () {
    it('strips single-line comments', function () {
        $detector = new SchedulerDetector;
        $reflection = new ReflectionClass($detector);
        $method = $reflection->getMethod('stripComments');
        $method->setAccessible(true);

        $content = '<?php
$schedule->command("test"); // this is a comment
$foo = "bar";';

        $result = $method->invoke($detector, $content);

        expect($result)->toContain('$schedule->command("test");');
        expect($result)->not->toContain('this is a comment');
    });

    it('strips multi-line comments', function () {
        $detector = new SchedulerDetector;
        $reflection = new ReflectionClass($detector);
        $method = $reflection->getMethod('stripComments');
        $method->setAccessible(true);

        $content = '<?php
/* This is a
   multi-line comment */
$schedule->command("test");';

        $result = $method->invoke($detector, $content);

        expect($result)->toContain('$schedule->command("test");');
        expect($result)->not->toContain('multi-line comment');
    });

    it('strips doc block comments', function () {
        $detector = new SchedulerDetector;
        $reflection = new ReflectionClass($detector);
        $method = $reflection->getMethod('stripComments');
        $method->setAccessible(true);

        $content = '<?php
/**
 * Schedule tasks
 * @param Schedule $schedule
 */
$schedule->command("test");';

        $result = $method->invoke($detector, $content);

        expect($result)->toContain('$schedule->command("test");');
        expect($result)->not->toContain('Schedule tasks');
    });

    it('preserves URLs in strings', function () {
        $detector = new SchedulerDetector;
        $reflection = new ReflectionClass($detector);
        $method = $reflection->getMethod('stripComments');
        $method->setAccessible(true);

        $content = '<?php
$url = "https://example.com/path";
$schedule->command("test");';

        $result = $method->invoke($detector, $content);

        expect($result)->toContain('https://example.com/path');
        expect($result)->toContain('$schedule->command("test");');
    });

    it('preserves hash symbols in strings', function () {
        $detector = new SchedulerDetector;
        $reflection = new ReflectionClass($detector);
        $method = $reflection->getMethod('stripComments');
        $method->setAccessible(true);

        $content = '<?php
$color = "#ff0000";
$schedule->command("test");';

        $result = $method->invoke($detector, $content);

        expect($result)->toContain('#ff0000');
        expect($result)->toContain('$schedule->command("test");');
    });
});

describe('NixpacksGenerator error handling', function () {
    it('writes to custom path', function () {
        $generator = new NixpacksGenerator;
        $generator->detect();

        $customPath = base_path('custom-nixpacks.toml');
        $path = $generator->write($customPath);

        expect($path)->toBe($customPath);
        expect(File::exists($customPath))->toBeTrue();

        // Clean up
        File::delete($customPath);
    });

    it('overwrites existing file', function () {
        $path = base_path('nixpacks.toml');
        File::put($path, '# old content');

        $generator = new NixpacksGenerator;
        $generator->detect();
        $generator->write();

        $content = File::get($path);
        expect($content)->toContain('# Generated by laravel-coolify');
        expect($content)->not->toContain('# old content');
    });

    it('generates processes section when detectors have processes', function () {
        // Mock scenario: if we had detected packages with processes
        $generator = new NixpacksGenerator;
        $generator->detect();

        $summary = $generator->getSummary();

        // Should always have web process
        expect($summary['processes'])->toHaveKey('web');
    });

    it('throws exception when directory does not exist', function () {
        $generator = new NixpacksGenerator;
        $generator->detect();

        $invalidPath = '/nonexistent/directory/nixpacks.toml';

        expect(fn () => $generator->write($invalidPath))
            ->toThrow(\InvalidArgumentException::class, 'Directory does not exist');
    });

    it('throws exception when path is outside project directory', function () {
        $generator = new NixpacksGenerator;
        $generator->detect();

        // Try to write outside of project directory
        $outsidePath = '/tmp/nixpacks.toml';

        expect(fn () => $generator->write($outsidePath))
            ->toThrow(\InvalidArgumentException::class, 'Path must be within the project directory');
    });
});

describe('NixpacksGenerator caching', function () {
    it('caches detection results on subsequent calls', function () {
        $generator = new NixpacksGenerator;

        // First call runs detection
        $first = $generator->detect();

        // Second call should return cached results
        $second = $generator->detect();

        expect($first)->toBe($second);
    });

    it('returns detected packages from getDetected after detect', function () {
        $generator = new NixpacksGenerator;
        $detected = $generator->detect();

        expect($generator->getDetected())->toBe($detected);
    });
});

describe('NixpacksGenerator node dependencies', function () {
    it('excludes node commands when no package.json', function () {
        // Ensure no package.json exists
        $packageJson = base_path('package.json');
        if (File::exists($packageJson)) {
            File::delete($packageJson);
        }

        $generator = new NixpacksGenerator;
        $generator->detect();

        $content = $generator->generate();

        expect($content)->not->toContain('npm ci');
        expect($content)->not->toContain('npm run build');
    });

    it('includes nodejs in nix packages when package.json exists', function () {
        File::put(base_path('package.json'), '{}');

        $generator = new NixpacksGenerator;
        $generator->detect();

        $summary = $generator->getSummary();

        expect($summary['nix_packages'])->toContain('nodejs_20');

        // Clean up
        File::delete(base_path('package.json'));
    });

    it('excludes nodejs from nix packages when no package.json', function () {
        $packageJson = base_path('package.json');
        if (File::exists($packageJson)) {
            File::delete($packageJson);
        }

        $generator = new NixpacksGenerator;
        $generator->detect();

        $summary = $generator->getSummary();

        expect($summary['nix_packages'])->not->toContain('nodejs_20');
    });
});

describe('HorizonDetector additional tests', function () {
    it('returns empty build commands', function () {
        $detector = new HorizonDetector;

        expect($detector->getBuildCommands())->toBe([]);
    });

    it('returns empty env vars', function () {
        $detector = new HorizonDetector;

        expect($detector->getEnvVars())->toBe([]);
    });

    it('detects when Horizon class exists', function () {
        $detector = new HorizonDetector;

        // In test environment, Horizon is not installed
        expect($detector->isInstalled())->toBeFalse();
    });
});

describe('ReverbDetector additional tests', function () {
    it('returns empty nix packages', function () {
        $detector = new ReverbDetector;

        expect($detector->getNixPackages())->toBe([]);
    });

    it('returns empty build commands', function () {
        $detector = new ReverbDetector;

        expect($detector->getBuildCommands())->toBe([]);
    });

    it('returns empty env vars', function () {
        $detector = new ReverbDetector;

        expect($detector->getEnvVars())->toBe([]);
    });

    it('detects when Reverb class exists', function () {
        $detector = new ReverbDetector;

        // In test environment, Reverb is not installed
        expect($detector->isInstalled())->toBeFalse();
    });
});
