<?php

declare(strict_types=1);

use Illuminate\Support\Facades\File;
use Stumason\Coolify\Nixpacks\Detectors\HorizonDetector;
use Stumason\Coolify\Nixpacks\Detectors\ReverbDetector;
use Stumason\Coolify\Nixpacks\Detectors\SchedulerDetector;
use Stumason\Coolify\Nixpacks\NixpacksGenerator;

beforeEach(function () {
    $path = base_path('nixpacks.toml');
    if (File::exists($path)) {
        File::delete($path);
    }
});

afterEach(function () {
    $path = base_path('nixpacks.toml');
    if (File::exists($path)) {
        File::delete($path);
    }
});

describe('NixpacksGenerator', function () {
    it('detects installed packages', function () {
        $generator = new NixpacksGenerator;
        $detected = $generator->detect();

        expect($detected)->toBeArray();
    });

    it('generates valid toml content with supervisor setup', function () {
        $generator = new NixpacksGenerator;
        $generator->detect();

        $content = $generator->generate();

        // Core structure
        expect($content)->toContain('# Generated by laravel-coolify');
        expect($content)->toContain('[phases.setup]');
        expect($content)->toContain('[phases.install]');
        expect($content)->toContain('[phases.build]');
        expect($content)->toContain('[phases.postbuild]');
        expect($content)->toContain('[start]');
        expect($content)->toContain('[staticAssets]');

        // Supervisor setup
        expect($content)->toContain('supervisord.conf');
        expect($content)->toContain('worker-nginx.conf');
        expect($content)->toContain('worker-phpfpm.conf');
        expect($content)->toContain('php-fpm.conf');
        expect($content)->toContain('nginx.template.conf');
        expect($content)->toContain('start.sh');

        // Composer and optimize run in postbuild (after COPY)
        expect($content)->toContain('composer install');
        expect($content)->toContain('php artisan optimize');
    });

    it('writes nixpacks.toml file', function () {
        $generator = new NixpacksGenerator;
        $generator->detect();

        $path = $generator->write();

        expect(File::exists($path))->toBeTrue();
        expect(File::get($path))->toContain('[phases.setup]');
    });

    it('detects when nixpacks.toml exists', function () {
        $generator = new NixpacksGenerator;

        expect($generator->exists())->toBeFalse();

        File::put(base_path('nixpacks.toml'), '# test');

        expect($generator->exists())->toBeTrue();
    });

    it('includes node build commands when package.json exists', function () {
        File::put(base_path('package.json'), '{}');

        $generator = new NixpacksGenerator;
        $generator->detect();

        $content = $generator->generate();

        expect($content)->toContain('npm ci');
        expect($content)->toContain('npm run build');
        expect($content)->toContain('nodejs_22');

        File::delete(base_path('package.json'));
    });

    it('returns summary of generated config', function () {
        $generator = new NixpacksGenerator;
        $generator->detect();

        $summary = $generator->getSummary();

        expect($summary)->toHaveKeys(['packages', 'workers', 'php_extensions']);
        expect($summary['workers'])->toContain('nginx');
        expect($summary['workers'])->toContain('php-fpm');
        expect($summary['php_extensions'])->toContain('redis');
    });

    it('includes supervisor and nginx in nix packages', function () {
        $generator = new NixpacksGenerator;
        $generator->detect();

        $content = $generator->generate();

        expect($content)->toContain('nginx');
        expect($content)->toContain('supervisor');
        expect($content)->toContain('php84');
    });

    it('configures php-fpm pool settings from config', function () {
        config(['coolify.nixpacks.phpfpm.max_children' => 100]);

        $generator = new NixpacksGenerator;
        $generator->detect();

        $content = $generator->generate();

        expect($content)->toContain('pm.max_children = 100');

        config(['coolify.nixpacks.phpfpm.max_children' => 50]);
    });

    it('generates proper nginx template with Laravel routes', function () {
        $generator = new NixpacksGenerator;
        $generator->detect();

        $content = $generator->generate();

        expect($content)->toContain('root /app/public');
        expect($content)->toContain('/index.php?$query_string');
        expect($content)->toContain('fastcgi_pass 127.0.0.1:9000');
    });

    it('uses auto worker_processes in nginx config', function () {
        $generator = new NixpacksGenerator;
        $generator->detect();

        $content = $generator->generate();

        expect($content)->toContain('worker_processes auto');
    });

    it('generates start script with migrations', function () {
        $generator = new NixpacksGenerator;
        $generator->detect();

        $content = $generator->generate();

        expect($content)->toContain('php artisan migrate --force --no-interaction');
        expect($content)->toContain('php artisan storage:link');
        expect($content)->toContain('supervisord -c /etc/supervisord.conf -n');
    });

    it('runs composer in postbuild phase after COPY', function () {
        $generator = new NixpacksGenerator;
        $generator->detect();

        $content = $generator->generate();

        // postbuild runs after COPY so vendor persists in final image
        expect($content)->toContain('[phases.postbuild]');
        expect($content)->toContain('composer install --no-dev --optimize-autoloader');
        expect($content)->toContain('php artisan optimize');
    });
});

describe('HorizonDetector', function () {
    it('returns correct name', function () {
        $detector = new HorizonDetector;

        expect($detector->name())->toBe('Laravel Horizon');
    });

    it('returns supervisor worker config', function () {
        $detector = new HorizonDetector;

        $config = $detector->getSupervisorConfig();

        expect($config)->toContain('[program:worker-horizon]');
        expect($config)->toContain('php /app/artisan horizon');
        expect($config)->toContain('autostart=true');
        expect($config)->toContain('autorestart=true');
        expect($config)->toContain('stopwaitsecs=3600');
    });

    it('returns redis and pcntl php extensions', function () {
        $detector = new HorizonDetector;

        expect($detector->getPhpExtensions())->toContain('redis');
        expect($detector->getPhpExtensions())->toContain('pcntl');
    });

    it('returns no nginx location blocks', function () {
        $detector = new HorizonDetector;

        expect($detector->getNginxLocationBlocks())->toBe([]);
    });

    it('detects when Horizon class exists', function () {
        $detector = new HorizonDetector;

        // In test environment, Horizon is not installed
        expect($detector->isInstalled())->toBeFalse();
    });
});

describe('ReverbDetector', function () {
    it('returns correct name', function () {
        $detector = new ReverbDetector;

        expect($detector->name())->toBe('Laravel Reverb');
    });

    it('returns supervisor worker config with internal port', function () {
        $detector = new ReverbDetector;

        $config = $detector->getSupervisorConfig();

        expect($config)->toContain('[program:worker-reverb]');
        expect($config)->toContain('reverb:start --host=127.0.0.1 --port=6001');
        expect($config)->toContain('autostart=true');
    });

    it('returns nginx websocket proxy location block', function () {
        $detector = new ReverbDetector;

        $blocks = $detector->getNginxLocationBlocks();

        expect($blocks)->toHaveCount(1);
        expect($blocks[0])->toContain('location /app');
        expect($blocks[0])->toContain('proxy_pass http://127.0.0.1:6001');
        expect($blocks[0])->toContain('proxy_http_version 1.1');
        expect($blocks[0])->toContain('Upgrade');
        expect($blocks[0])->toContain('Connection "upgrade"');
    });

    it('returns no php extensions', function () {
        $detector = new ReverbDetector;

        expect($detector->getPhpExtensions())->toBe([]);
    });

    it('detects when Reverb service provider exists', function () {
        $detector = new ReverbDetector;

        // In test environment, Reverb is not installed
        expect($detector->isInstalled())->toBeFalse();
    });
});

describe('SchedulerDetector', function () {
    it('returns correct name', function () {
        $detector = new SchedulerDetector;

        expect($detector->name())->toBe('Task Scheduler');
    });

    it('returns supervisor worker config', function () {
        $detector = new SchedulerDetector;

        $config = $detector->getSupervisorConfig();

        expect($config)->toContain('[program:worker-scheduler]');
        expect($config)->toContain('php /app/artisan schedule:work');
        expect($config)->toContain('autostart=true');
    });

    it('returns no nginx location blocks', function () {
        $detector = new SchedulerDetector;

        expect($detector->getNginxLocationBlocks())->toBe([]);
    });

    it('returns no php extensions', function () {
        $detector = new SchedulerDetector;

        expect($detector->getPhpExtensions())->toBe([]);
    });
});

describe('SchedulerDetector comment stripping', function () {
    it('strips single-line comments', function () {
        $detector = new SchedulerDetector;
        $reflection = new ReflectionClass($detector);
        $method = $reflection->getMethod('stripComments');
        $method->setAccessible(true);

        $content = '<?php
$schedule->command("test"); // this is a comment
$foo = "bar";';

        $result = $method->invoke($detector, $content);

        expect($result)->toContain('$schedule->command("test");');
        expect($result)->not->toContain('this is a comment');
    });

    it('strips multi-line comments', function () {
        $detector = new SchedulerDetector;
        $reflection = new ReflectionClass($detector);
        $method = $reflection->getMethod('stripComments');
        $method->setAccessible(true);

        $content = '<?php
/* This is a
   multi-line comment */
$schedule->command("test");';

        $result = $method->invoke($detector, $content);

        expect($result)->toContain('$schedule->command("test");');
        expect($result)->not->toContain('multi-line comment');
    });

    it('strips doc block comments', function () {
        $detector = new SchedulerDetector;
        $reflection = new ReflectionClass($detector);
        $method = $reflection->getMethod('stripComments');
        $method->setAccessible(true);

        $content = '<?php
/**
 * Schedule tasks
 * @param Schedule $schedule
 */
$schedule->command("test");';

        $result = $method->invoke($detector, $content);

        expect($result)->toContain('$schedule->command("test");');
        expect($result)->not->toContain('Schedule tasks');
    });

    it('preserves URLs in strings', function () {
        $detector = new SchedulerDetector;
        $reflection = new ReflectionClass($detector);
        $method = $reflection->getMethod('stripComments');
        $method->setAccessible(true);

        $content = '<?php
$url = "https://example.com/path";
$schedule->command("test");';

        $result = $method->invoke($detector, $content);

        expect($result)->toContain('https://example.com/path');
        expect($result)->toContain('$schedule->command("test");');
    });

    it('preserves hash symbols in strings', function () {
        $detector = new SchedulerDetector;
        $reflection = new ReflectionClass($detector);
        $method = $reflection->getMethod('stripComments');
        $method->setAccessible(true);

        $content = '<?php
$color = "#ff0000";
$schedule->command("test");';

        $result = $method->invoke($detector, $content);

        expect($result)->toContain('#ff0000');
        expect($result)->toContain('$schedule->command("test");');
    });
});

describe('NixpacksGenerator error handling', function () {
    it('writes to custom path', function () {
        $generator = new NixpacksGenerator;
        $generator->detect();

        $customPath = base_path('custom-nixpacks.toml');
        $path = $generator->write($customPath);

        expect($path)->toBe($customPath);
        expect(File::exists($customPath))->toBeTrue();

        File::delete($customPath);
    });

    it('overwrites existing file', function () {
        $path = base_path('nixpacks.toml');
        File::put($path, '# old content');

        $generator = new NixpacksGenerator;
        $generator->detect();
        $generator->write();

        $content = File::get($path);
        expect($content)->toContain('# Generated by laravel-coolify');
        expect($content)->not->toContain('# old content');
    });

    it('throws exception when directory does not exist', function () {
        $generator = new NixpacksGenerator;
        $generator->detect();

        $invalidPath = '/nonexistent/directory/nixpacks.toml';

        expect(fn () => $generator->write($invalidPath))
            ->toThrow(\InvalidArgumentException::class, 'Path must be within the project directory');
    });

    it('throws exception when path is outside project directory', function () {
        $generator = new NixpacksGenerator;
        $generator->detect();

        $outsidePath = '/tmp/nixpacks.toml';

        expect(fn () => $generator->write($outsidePath))
            ->toThrow(\InvalidArgumentException::class, 'Path must be within the project directory');
    });
});

describe('NixpacksGenerator caching', function () {
    it('caches detection results on subsequent calls', function () {
        $generator = new NixpacksGenerator;

        $first = $generator->detect();
        $second = $generator->detect();

        expect($first)->toBe($second);
    });

    it('returns detected packages from getDetected after detect', function () {
        $generator = new NixpacksGenerator;
        $detected = $generator->detect();

        expect($generator->getDetected())->toBe($detected);
    });
});

describe('NixpacksGenerator node dependencies', function () {
    it('excludes node commands when no package.json', function () {
        $packageJson = base_path('package.json');
        if (File::exists($packageJson)) {
            File::delete($packageJson);
        }

        $generator = new NixpacksGenerator;
        $generator->detect();

        $content = $generator->generate();

        expect($content)->not->toContain('"npm ci"');
        expect($content)->not->toContain('"npm run build"');
    });

    it('includes nodejs in nix packages when package.json exists', function () {
        File::put(base_path('package.json'), '{}');

        $generator = new NixpacksGenerator;
        $generator->detect();

        $content = $generator->generate();

        expect($content)->toContain('nodejs_22');

        File::delete(base_path('package.json'));
    });

    it('excludes nodejs from nix packages when no package.json', function () {
        $packageJson = base_path('package.json');
        if (File::exists($packageJson)) {
            File::delete($packageJson);
        }

        $generator = new NixpacksGenerator;
        $generator->detect();

        $content = $generator->generate();

        expect($content)->not->toContain('nodejs');
    });

    it('combines npm ci and npm run build in single command when package.json exists', function () {
        File::put(base_path('package.json'), '{}');

        $generator = new NixpacksGenerator;
        $generator->detect();

        $content = $generator->generate();

        // npm ci and npm run build must be in same command so node_modules persists
        // (Docker mount caching is ephemeral - only available during each RUN command)
        expect($content)->toContain('npm ci && npm run build');

        File::delete(base_path('package.json'));
    });

    it('does not cache node_modules (docker mount caching is ephemeral)', function () {
        File::put(base_path('package.json'), '{}');

        $generator = new NixpacksGenerator;
        $generator->detect();

        $content = $generator->generate();

        // node_modules should NOT be in cacheDirectories because Docker mount caching
        // is ephemeral and doesn't persist between build phases
        expect($content)->not->toContain('"node_modules"');

        File::delete(base_path('package.json'));
    });
});

describe('NixpacksGenerator detected package integration', function () {
    it('adds horizon worker config when horizon detected', function () {
        $detector = new HorizonDetector;
        $config = $detector->getSupervisorConfig();

        expect($config)->toContain('worker-horizon');
        expect($config)->toContain('horizon');
    });

    it('adds reverb worker config and nginx block when reverb detected', function () {
        $detector = new ReverbDetector;

        $supervisorConfig = $detector->getSupervisorConfig();
        $nginxBlocks = $detector->getNginxLocationBlocks();

        expect($supervisorConfig)->toContain('worker-reverb');
        expect($supervisorConfig)->toContain('reverb:start');
        expect($nginxBlocks[0])->toContain('location /app');
        expect($nginxBlocks[0])->toContain('proxy_pass');
    });

    it('adds scheduler worker config when scheduler detected', function () {
        $detector = new SchedulerDetector;
        $config = $detector->getSupervisorConfig();

        expect($config)->toContain('worker-scheduler');
        expect($config)->toContain('schedule:work');
    });
});
